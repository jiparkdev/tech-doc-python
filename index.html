<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Python Notes</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700;800;900&family=Roboto+Mono&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="global-container">
      <aside class="nav-container">
        <nav id="navbar">
          <header class="nav-header">Python Notes</header>
          <ul class="nav-list">
            <li class="nav-item">
              <a href="#Expressions_and_Statements" class="nav-link">Expressions and Statements</a>
            </li>
            <li class="nav-item">
              <a href="#Data_Types" class="nav-link">Data Types</a>
            </li>
            <li class="nav-item">
              <a href="#Operators" class="nav-link">Operators</a>
            </li>
            <li class="nav-item">
              <a href="#Mutability" class="nav-link">Mutability</a>
            </li>
            <li class="nav-item">
              <a href="#Name_Variable" class="nav-link">Name Variable</a>
            </li>
            <!-- <li class="nav-item">
              <a href="#Packages_and_Modules" class="nav-link">Packages and Modules</a>
            </li>
            <li class="nav-item">
              <a href="#Pass_Statement" class="nav-link">Pass Statement</a>
            </li>
            <li class="nav-item">
              <a href="#Assert_Statement" class="nav-link">Assert Statement</a>
            </li>
            <li class="nav-item">
              <a href="#Functions" class="nav-link">Functions</a>
            </li>
            <li class="nav-item">
              <a href="#Namespaces_and_Scopes" class="nav-link">Namespaces and Scopes</a>
            </li>
            <li class="nav-item">
              <a href="#Classes" class="nav-link">Classes</a>
            </li> -->
          </ul>
        </nav>
      </aside>
      <main id="main-doc">
        <section class="main-section" id="Expressions_and_Statements">
          <header class="section-title"><h1>Expressions and Statements</h1></header>
          <h2>Expression</h2>
          <p>An expression is a combination of values, variables, and operators.</p>
          <pre>
            <code>
    >>> 5 + 5 # addition expression
    10
    >>> n = 17 # assignment statement (with a numeric literal 17 as an expression)
    >>> n # variable expression
    17
    >>> n > 10 # boolean expression
    True
            </code>
          </pre>
          <p>When you execute an expression on Python interpreter prompt, the interpreter evaluates it. Evaluating an expression means to find the value of the expression.</p>
          <h2>Statement</h2>
          <p>A statement is a unit of code that has an effect, like creating a variable or displaying a value.</p>
          <p>An expression is a part of a statement. The expression gets evaluated first, and then the statement gets executed.</p>
          <pre>
            <code>
    # test.py

    n = 17 # assignment statement (with a numeric literal 17 as an expression)
    print n # print statement (with variable n as an expression)
    print n == 3 # print statement (with n == 3 as an expression)

    # =======================
    # Output
    # =======================
    17
    False
            </code>
          </pre>
          <ul>
            <li>Line #3 is an assignment statement where numeric literal 17 is an expression (which is a part of the statement).</li>
            <li>Line #4 is a print statement where variable n is an expression (which is a part of the statement).</li>
            <li>Line #5 is a print statement where <code>n == 3</code> is an expression (which is a part of the statement).</li>
          </ul>
        <h2>Main Takeaways</h2>
        <blockquote>An expression is a combination of values, variables, and operators (e.g. +, -, /, *, =, ==) that Python evaluates</blockquote>
        <blockquote>A statement is a unit of code that has an effect or carries out certain actions which Python executes.</blockquote>
        </section>
        <!-- =============================================================================================================================================================== -->
        <section class="main-section" id="Data_Types">
          <header class="section-title"><h1>Data Types</h1></header>
          <blockquote>In Python, everything is an object in the sense that it can be assigned to a variable or passed as an argument to a function.</blockquote>
          <p>An object is a block of information, which has (or, is of) some data type. For instance, in this code a = "Hi", the variable a is simply a label (or a box) that has a reference to the string literal "Hi", and the string literal "Hi" is an object. Furthermore, the variable a has a value that is of str string data type, and the string literal tiself "Hi" is of string data type.</p>
          <pre>
            <code>
    >>> my_fridge = "my refrigerator"
    >>> my_fridge
    "my refrigerator"
            </code>
          </pre>
          <p>
            In the above example, my_fridge is the sticky note or the label that you put on to your refrigerator, and the string literal "my refrigerator" is the actual representation of your refrigerator. Imagine yourself in your kitchen, and you have a sticky note and a pen in your hand. You write "my_fridge" on the sticky note and then you stick it on the door of you kitchen fridge. In this case, the sticky note with the word "my_fridge" is your variable, and the value for the variable is your refrigerator itself. In the same vein, your refrigerator is an object that has been referenced by your variable.
          </p>
          <blockquote>
            In Python, all values of all its data types are objects, and even all the Python functions and the functions that you define for yourself are objects. They can be assigned to a variable or passed as an argument to a function; yes, you can even assign a function to a variable or even pass it to another function as an argument.
          </blockquote>
          <h2>Python Data Types</h2>
          <p>
            In Python, there are a total of eleven built-in basic data types: int, float, long, complex, bool, str, list, tuple, dict, set, frozenset, bytes. Python has more data types (higher-level data types), but the data types that are define in this document are the basic building blocks of other higher-level data types are created. In practice, we will rarely encounter objects that are of long, complex, frozenset, and bytes data types.
          </p>
          <p>
            In this document, we will focus on a total of eight built-in data types that are most commonly used in many Python applications: int, float, bool, str, list, tuple, dict, set.
          </p>
          <h3>Numeric Data Type</h3>
          <p>
            There are a total of four numeric data types in Python: int, float, long, and complex. Python int is written as I = -12, float as F = 1.2, long as l = 123L, and complex as C = 2.4+0j. We will rarely encounter objects that are of long and complex data types.
          </p>
          <h3>Boolean Data Type</h3>
          <p>
            Booleans represent the truth values False and True. The two objects reresenting the values False and True are the only Boolean objects in Python. The Boolean type is a subtype of the int data type; which means that the Boolean values behave like the integer values 0 and 1 (0 for False and 1 for True). Python booleans are written in the following way: B1 = True, B2 = False.
          </p>
          <h3>String Data Type</h3>
          <p>
            An object that is of the string data type can simply be called a "string". Strings can be enclosed in single quotes or double quotes. A string is a sequence of characters (i.e. letters, numbers, symbols). Python strings are written in the following way: S1 = 'foo', S2 = "bar".
          </p>
          <h3>List Data Type</h3>
          <p>
            An object that is of list data type can simply be called a "list". A list is the most versatile object in Python and it can be written as a sequence of comma-separated objects, all enclosed in square brackets. Lists can contain items of different types. Python lists are written in square brackets like so: L = [1, 2, 3].
          </p>
          <h3>Tuple Data Type</h3>
          <p>
            An object that is of tuple data type can simply be called a "tuple". A tuple is like a list, but once it is created, none of the items within tuple cannot be modified during the execution of the program. Python tuples are written with parentheses like so: T = (1, 2, 3).
          </p>
          <h3>Dictionary Data Type</h3>
          <p>
            An object that is of dictionary data type can simply be called a "dictionary". A dictionary is a collection of key-value entries/items. All the entries in a dictionary is unordered, modficable/mutable, and can be indexed by their keys. A dictionary must be written with curly brackets, and for every entry, there has to be a key, followed by a colon : , and then the value associated with the key. You can write a dictionary in the following way: D = {"A": 2.4, "B": 3}. Both the keys and the values of a dictionary can be of any data type mentioned above.
          </p>
          <h3>Set Data Type</h3>
          <p>
            An object that is of set data type can simply be called a "set". A set is an unordered collection of items which is iterable (i.e. you can iterate through the items of the object using for-loop), mutable, and has no duplicate elements. The major advantage of using a set, as opposed to a list, is that it has a highly optimized method for checking whether a specific item is contained in the set. In Python, a set is written with curly brackets: S = {"Apple", "Banana", "Cherry"}.
          </p>
        </section>
        <!-- =============================================================================================================================================================== -->
        <section class="main-section" id="Operators">
          <header class="section-title"><h1>Operators</h1></header>
          <ul>
            <li>Arithmetic operators: +, -, *, /, //, %, **</li>
            <li>Assignment operators: =, +=, -=, *=, /=, //=, %=, **=</li>
            <li>Comparison operators: ==, !=, >, <, >=, <=</li>
            <li>Logical operators: and, or, not</li>
            <li>Identity operators: is, is not</li>
            <li>Membership operators: in, not in</li>
            <li>Bitwise operators: &, |, ^, >>, <<, ~</li>
          </ul>
          <h2>Arithmetic Operators</h2>
          <p>
            There are a total of seven arithmetic operators in Python. Here are the four basic operators: addition +, subtraction -, multiplication *, division / . There are three more arithmetic operators which might be unfamiliar to you: modulus %, exponentiation **, and the floor division //.
          </p>
          <h3>Modulus Operator</h3>
          <p>Modulus operator % gets the remainder of a division.</p>
          <pre>
            <code>
    >>> 5 % 2
    1
            </code>
          </pre>
          <h3>Exponentiation Operator</h3>
          <pre>
            <code>
    >>> 2**2
    4
            </code>
          </pre>
          <h3>Floor Division</h3>
          <p>Floor division operator // gets the quotient of a division. It is a division in which the remainder is discarded.</p>
          <pre>
            <code>
    >>> 5 // 2
    2
            </code>
          </pre>
          <h2>Assignment Operators</h2>
          <p>
            Assignment operators are used to assign values to variables. There are a total of eight assignment operators in Python: =, +=, -=, *=, /=, //=, %=, **=. The single equal sign assignment operator = is the basic operator that simply assigns a value.
          </p>
          <h3>Single Assignment</h3>
          <pre>
            <code>
    >>> number = 5
    >>> number
    5
            </code>
          </pre>
          <h3>Multiple Assignment</h3>
          <pre>
            <code>
    >>> first_var, second_var = 0, 1
    >>> first_var
    0
    >>> second_var
    1
            </code>
          </pre>
          <h3>Swapping Values with Multiple Assignment</h3>
          <pre>
            <code>
    >>> first_var, second_var = 0, 1
    >>> first_var, second_var = second_var, first_var
    >>> first_var
    1
    >>> second_var
    0
            </code>
          </pre>
          <h3>Augmented Assignment Operators</h3>
          <p>
            An assignment operator combined with arithmetic operators.
          </p>
          <pre>
            <code>
    >>> number = 5
    >>> number += 3 # number = 5 + 3
    >>> number
    8
    >>> number -= 3 # number = 8 - 3
    >>> number
    5
    >>> number *= 3 # number = 5 * 3
    >>> number
    15
    >>> number /= 2 # number = 15 / 2
    >>> number
    7
    >>> number %= 2 # number = 7 % 2
    >>> number
    1
    >>> number += 9 # number = 1 + 9
    >>> number //= 3 # number = 10 // 3
    >>> number
    3
    >>> number **= 2 # number = 3 ** 2
    >>> number
    9
            </code>
          </pre>
          <p>
            As you can see from the above example, the assignment operators that are augmented with the arithmetic operators carry out the arithmetic operations implicitly and then overwrites the existing variable with the resulting value.
          </p>
          <p>
            If we take line #2 for example, the number variable initially has the value 5, but the augmented operator += tells Python to evaluate number + 3 first and then overwrite the number variable with the resulting value of 8 .
          </p>
          <h2>Comparison Operators</h2>
          <p>Comparison operators are used in comparing two values.</p>
          <p>
            There are a total of six comparison operators in Python: equal-to operator: ==, not-equal-to operator: !=, greater-than operator: >, less-than operator: <, greater-than-or-equal-to operator: >=, less-than-or-equal-to operator: <=.
          </p>
          <h2>Logical Operators</h2>
          <p>Logical operators are used for combining conditional expressions.</p>
          <p>There are a total of three logical operators: and operator: and, or operator: or, and the not operator: not.</p>
          <pre>
            <code>
    # the `and` operator
    >>> first_number = 5
    >>> second_number = 10
    >>> first_number > 0 and second_number < 20
    True

    # the `or` operator
    >>> first_number > 5 or second_number < 20
    True

    # the `not` operator
    >>> not first_number == second_number
    True
            </code>
          </pre>
          <p>
            Line #4's conditional expression first_number > 5 and second_number < 20 is evaluated to True only if both sides (left-side and right-side of the and operator) of the expression evaluate to True.
          </p>
          <p>
            Line #8's conditional expression first_number > 5 or second_number < 20 should evaluate to True, only if either side of the or operator evaluates to True. In this case, second_number < 20 evaluated to True; therefore, the entire expression on line #8 is evaluated to True.
          </p>
          <p>
            Line #12's conditional expression first_number == second_number should evalute to True, only if the right-side of the expression first_number == second_number evaluates to False. In this case, first_number is not equal to second_number; therefore first_number == second_number will evaluate to False; therefore the not operator will evalute the entire expression at line #12 to True. Essentially, the not operator reverses the boolean value that is given to it.
          </p>
          <h2>Identity Operators</h2>
          <p>
            The identify operators are used for checking if two objects are referencing the same memory location on the system. In other words, they're used to compare if two objects have the same identity. The identity operators are not used for comparing whether or not the two objects have the same value.
          </p>
          <p>
            There are a total of two identity operators: is operator: is and the is-not operator: is not.
          </p>
          <blockquote>Identity operators are used for checking if two objects have the same identity.</blockquote>
          <h3>How to Retrieve the Identity of an Object</h3>
          <p>Given a list containing a various elements, we can retrieve the identity of the list by using a built-in Python function called id().</p>
          <pre>
            <code>
    >>> L = ["Hello", 2.5, "Good", 1]
    >>> id(L)
    57448264L
            </code>
          </pre>
          <p>
            In the above example, we created a list with various elements, and called the id() function with the list as its argument. We then get an output of 57448264L. The identity that gets returned from the id() function will be different depending on the system that the Python program is run.
          </p>
          <h3>is Operator</h3>
          <p>The is identity operator will tell Python to evaluate an identity expression within which it resides to True if both sides of the operator have the same identity.</p>
          <pre>
            <code>
    >>> L1 = ["Apple", "Banana"]
    >>> L2 = ["Apple", "Banana"]
    >>> L1 is L2
    False
            </code>
          </pre>
          <h3>is not Operator</h3>
          <p>The is not identity operator will tell Python to evaluate an identity expression within which it resides to True if both sides of the operator have different identities.</p>
          <pre>
            <code>
    >>> L1 = ["Apple", "Banana"]
    >>> L2 = ["Apple", "Banana"]
    >>> L1 is not L2
    True
            </code>
          </pre>
          <h3>In Contrast to the == and != Comparison Operators</h3>
          <pre>
            <code>
    >>> L1 = ["Apple", "Banana"]
    >>> L2 = ["Apple", "Banana"]
    >>> L1 is L2
    False
    >>> L1 is not L2
    True
    >>> L1 == L2
    True
    >>> L1 != L2
    False
            </code>
          </pre>
          <p>
            As you can see from the above example, the == and != comparison operators compares the values within the two lists. L1 does have the same values as L2 does, so using == for comparison will evalute to True, and since L1 and L2 have the same values, using != will evalute to False.
          </p>
          <h2>Membership Operators</h2>
          <p>The membership operators are used for checking if an object exists in a sequence of objects.</p>
          <p>There are a total of two membership operators in Python: in operator: in and the not-in operator: not in.</p>
          <pre>
            <code>
    >>> L = ["Apple", "Banana"]
    >>> "Banana" in L
    True
    >>> "Peach" not in L
    True
    >>> "Watermelon" in L
    False
    >>> "Apple" not in L
    False
            </code>
          </pre>
          <p>
            As you can see from the example above, the "Banana" object (a string literal) exists in the list L; therefore, the expression "Banana" in L will evaluate to True. Also, since the object "Peach" (another string literal) does not exist in the list L, the expression "Peach" not in L will evaluate to True.
          </p>
        </section>
        <!-- =============================================================================================================================================================== -->
        <section class="main-section" id="Mutability">
          <header class="section-title"><h1>Mutability</h1></header>
          <h2>Definition</h2>
          <blockquote>Mutable: Liable to change. Mutable objects can be changed.</blockquote>
          <blockquote>Immutable: Unchanging over time or unable to be changed. Immutable objects cannot be changed.</blockquote>
          <blockquote>In Python, everything is an object, and every object has (or is of) a data type, and depending on the data type, an object can either be mutable or immutable.</blockquote>
          <h2>Mutable & Immutable</h2>
          <p>
            A list is mutable; it can have items/values added, removed, or changed. A string is immutable; you cannot have its characters removed or changed, and you cannot add more characters to it. If you want to remove some characters in a string, you have to create a new string without those characters.
          </p>
          <p>
            If we try to modify a single character in a string in-place, we will encounter a TypeError exception:
          </p>
          <pre>
            <code>
    >>> name = "King is a cat"
    >>> name[8] = "the"
    Traceback (most recent call last):
      File "<pyshell#50>", line 1, in <module>
        name[8] = 'the'
    TypeError: 'str' object does not support item assignment
            </code>
          </pre>
          <p>
            The proper way to "mutate" a string is to use slicing and concatenation to build a new string by copying from the parts of the old string:
          </p>
          <pre>
            <code>
    >>> name = "King is a cat"
    >>> new_name = name[0:5] + "the" + name[9:13]
    >>> name
    'King is a cat'
    >>> new_name
    'King the cat'
            </code>
          </pre>
          <p>
            As you can see from the above example, we used [0:5] and [9:13] to refer to the characters that we wanted to keep, and notice that the original "King is a cat" string is not modified because a string is immutable.
          </p>
          <h2>Mutable Objects</h2>
          <p>
            Mutable objects in Python are: lists, dictionaries, and sets. The values that are contained in lists, dictionaries, and sets can be changed in-place without having to create a separate copy of them with the changes. Now, we will have a look at some examples of a list object.
          </p>
          <blockquote>In Python, mutable objects are those whose values can be changed in-place after assignment.</blockquote>
          <h3>List (mutable)</h3>
          <p>Although a list is mutable, the second line in the following code does not modify the list what is stored in eggs:</p>
          <pre>
            <code>
    >>> eggs = [1, 2, 3]
    >>> eggs = [4, 5, 6]
    >>> eggs
    [4, 5, 6]
            </code>
          </pre>
          <p>
            The list [1, 2, 3] which is stored in the eggs variable is not being changed here; rather, an entirely new and different list [4, 5, 6] gets referenced by the eggs variable; you're not actually modifying the values of the list [1, 2, 3] itself.
          </p>
          <p>If you wanted to actually modify the original list in eggs , you would have to do something like the following:</p>
          <pre>
            <code>
    >>> eggs = [1, 2, 3]
    >>> del eggs[2]
    >>> del eggs[1]
    >>> del eggs[0]
    >>> eggs.append(4)
    >>> eggs.append(5)
    >>> eggs.append(6)
    >>> eggs
    [4, 5, 6]
            </code>
          </pre>
          <p>Or you can do it like this:</p>
          <pre>
            <code>
    >>> eggs = [1, 2, 3]
    >>> eggs[0] = 4
    >>> eggs[1] = 5
    >>> eggs[2] = 6
    >>> eggs
    [4, 5, 6]
            </code>
          </pre>
          <h2>Immutable Objects</h2>
          <p>
            Immutable objects in Python are: integers, floats, strings, and tuples. Once you create a variable which has a value that is immutable, you cannot change the value in-place.
          </p>
          <blockquote>
            In Python, immutable objects are those whose values cannot be changed in-place after assignment.
          </blockquote>
          <h3>Strings (immutable)</h3>
          <p>
            List is not the only thing that represents an ordered sequence of values. For example, strings and lists are actually very similar if you consider a string to be a "list" of characters. Many of the things you can do with lists can also be done with strings: indexing, slicing, and using them with loops, using len() function to get the length of the string, and in and the not in operators to see if some characters exist in the string.
          </p>
          <pre>
            <code>
    >>> name = "abc"
    >>> name[0]
    'a'
    >>> name[-2]
    'b'
    >>> name[0:3] # slicing
    'abc'
    >>> "a" in name
    True
    >>> "z" in name
    False
    >>> for i in name:
        print i
    a
    b
    c
            </code>
          </pre>
          <h3>Tuple (immutable)</h3>
          <p>The tuple data type is almost identical to the list data type, except in two ways. First, tuples are written with parentheses, ( and ) instead of square brackets [ and ].</p>
          <pre>
            <code>
    >>> eggs = ("hello", 42, 0.5)
    >>> eggs[0]
    'hello'
    >>> eggs[1:3]
    (42, 0.5)
    >>> len(eggs)
    3
            </code>
          </pre>
          <p>
            However, tuples are different from lists in that, tuples, like strings, are immutable. Tuples cannot have their values modified, appended, or removed in-place.
          </p>
          <p>Here is an example that attempts to modify a value in a tuple.</p>
          <pre>
            <code>
    >>> eggs = ("hello", 42, 0.5)
    >>> eggs[1] = 99
    Traceback (most recent call last):
      File "<pyshell#5>", line 1, in <module>
        eggs[1] = 99
    TypeError: 'tuple' object does not support item assignment
            </code>
          </pre>
          <h4>Benefits of Tuples</h4>
          <p>
            You can use tuples to convey to anyone reading your code that you do not intend for that sequence of values to change. If you need an ordered sequence of values that never changes, use a tuple.
          </p>
          <p>
            A second benefit of using tuples instead of lists is that, because they are immutable and their contents do not change, Python can implement some optimizations that make code using tuples slightly faster than code using lists.
          </p>
          <h2>Mutable & Immutable Objects as Function Arguments</h2>
          <blockquote>
            When a variable (which has a mutable object) is passed as an argument to a function, the reference to the object is passed and the parameter of the function will then have the reference to the object.
          </blockquote>
          <blockquote>
            When a variable (which has an immutable object) is passed as an argument to a function, a complete copy of the value is created and assigned to the parameter of the function.
          </blockquote>
        </section>
        <!-- =============================================================================================================================================================== -->
        <section class="main-section" id="Name_Variable">
          <header class="section-title"><h1>Name Variable</h1></header>
          <p>
            The __name__ variable is a built-in variable which will automatically be assigned a value by Python when a Python code is executed. It contains the name of the module that is being executed.
          </p>
          <h2>Main Module and the __name__ Variable</h2>
          <p>Let us say that there is a module called foo.py, and within it, there is just a single line of code: print __name__.</p>
          <pre>
            <code>
    # foo.py
    print __name__

    # ======
    # Output
    # ======
    __main__
            </code>
          </pre>
          <p>Now, when you execute foo.py from the command prompt, the string "__main__" will be printed out.</p>
          <p>The __name__ variable contains the string "__main__" if you execute the module directly.</p>
          <h2>Imported Module and the __name__ Variable</h2>
          <p>
            The __name__ variable will have the string "__main__" only if you are executing a module directly from the command prompt. However, if you are importing a module from another module, then that first module's __name__ variable will have its module's name in string.
          </p>
          <pre>
            <code>
    # =========================
    # foo.py
    # =========================

    print "foo's __name__ :", __name__

    # =========================
    # bar.py
    # =========================

    import foo.py

    print "bar's __name__ :", __name__
            </code>
          </pre>
          <p>
            If you execute the bar module above, you will notice that it will immediately print out "foo's __name__ : foo " and then print out "bar's __name__ : __main__". As you can see, since you directly executed the bar module from the command prompt, its __name__ variable has the string "__main__", and since the foo module was an imported module, its __name__ variable has the string foo .
          </p>
          <h2>Main Takeaway</h2>
          <blockquote>You must write if __name__ == "__main__": in every module that you plan to directly execute on CMD.</blockquote>
          <pre>
            <code>
    # module.py

    # your import statements go here.
    import math

    # your global constants go here.
    GLOBAL_VAR1 = 3.4123

    def foo():
        # function foo's code goes here.

    def bar():
        # function bar's code goes here.

    if __name__ == "__main__":
      # Your main code goes here.
        # All your module-wide variables should be defined here.
        # All your function calls should be written here.
        # ... etc.
        x = 0
        y = 1
        # ... etc.
        foo()
        bar()
        # ... etc.
            </code>
          </pre>
        </section>
        <!-- =============================================================================================================================================================== -->
        <!-- <section class="main-section" id="Packages_and_Modules">
          <header class="section-title"><h1>Packages and Modules</h1></header>
        </section> -->
        <!-- =============================================================================================================================================================== -->
        <!-- <section class="main-section" id="Pass_Statement">
          <header class="section-title"><h1>Pass Statement</h1></header>
        </section> -->
        <!-- =============================================================================================================================================================== -->
        <!-- <section class="main-section" id="Assert_Statement">
          <header class="section-title"><h1>Assert Statement</h1></header>
        </section> -->
        <!-- =============================================================================================================================================================== -->
        <!-- <section class="main-section" id="Functions">
          <header class="section-title"><h1>Functions</header>
        </section> -->
        <!-- =============================================================================================================================================================== -->
        <!-- <section class="main-section" id="Namespaces_and_Scopes">
          <header class="section-title"><h1>Namespaces and Scopes</h1></header>
        </section> -->
        <!-- =============================================================================================================================================================== -->
        <!-- <section class="main-section" id="Classes">
          <header class="section-title"><h1>Classes</h1></header>
        </section> -->
        <!-- =============================================================================================================================================================== -->
      </main>
    </div>
  </body>
</html>
